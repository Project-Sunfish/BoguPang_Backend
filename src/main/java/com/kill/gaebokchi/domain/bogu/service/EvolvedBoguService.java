package com.kill.gaebokchi.domain.bogu.service;import com.kill.gaebokchi.domain.bogu.entity.Category;import com.kill.gaebokchi.domain.bogu.entity.DefaultBogu;import com.kill.gaebokchi.domain.bogu.entity.EvolvedBogu;import com.kill.gaebokchi.domain.bogu.entity.Type;import com.kill.gaebokchi.domain.bogu.entity.dto.EvolutionRequestDTO;import com.kill.gaebokchi.domain.bogu.entity.dto.EvolvedBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.entity.dto.PopBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.repository.DefaultBoguRepository;import com.kill.gaebokchi.domain.bogu.repository.EvolvedBoguRepository;import com.kill.gaebokchi.domain.user.entity.Member;import com.kill.gaebokchi.domain.user.repository.MemberRepository;import com.kill.gaebokchi.global.error.BadRequestException;import com.kill.gaebokchi.global.error.ExceptionCode;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.cglib.core.Local;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.Duration;import java.time.LocalDateTime;import java.util.Collections;import java.util.List;import java.util.Optional;import java.util.Random;import java.util.stream.Collectors;import static com.kill.gaebokchi.global.error.ExceptionCode.*;@Service@Slf4j@Transactional(readOnly = true)@RequiredArgsConstructorpublic class EvolvedBoguService {    private final EvolvedBoguRepository evolvedBoguRepository;    private final DefaultBoguRepository defaultBoguRepository;    private final DefaultBoguService defaultBoguService;    public EvolvedBoguResponseDTO findEvolvedBoguByID(Long id) {        EvolvedBogu evolvedBogu = evolvedBoguRepository.findById(id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        return EvolvedBoguResponseDTO.from(evolvedBogu);    }    public List<EvolvedBoguResponseDTO> findEvolvedBoguByHost(Member member){        List<EvolvedBogu> evolvedBogus = evolvedBoguRepository.findByHost(member);        return evolvedBogus.stream()                .map(EvolvedBoguResponseDTO::from)                .collect(Collectors.toList());    }    @Transactional    public List<EvolvedBogu> findAndUpdateEvolvedBoguByHost(Member member){        List<EvolvedBogu> findList = evolvedBoguRepository.findByHost(member);        for(EvolvedBogu findOne : findList){            Integer findCount = findOne.getCount();            Integer findLevel = findOne.getLevel();            LocalDateTime findCreatedAt = findOne.getCreatedAt();            LocalDateTime findBangAt = findOne.getLastBangAt();            Integer newStatus = getStatus(findLevel, findCreatedAt);            findOne.setStatus(newStatus);            if(!findOne.getIsLiberated()){ //해방되지 않았을 경우 리스폰                Integer newCount = getCount(findCount, findLevel, findBangAt);                findOne.setCount(newCount);            }        }        return findList;    }    @Transactional    public Long saveEvolvedBogu(EvolutionRequestDTO evolutionRequestDTO){        if(evolutionRequestDTO.hasNullFields()){            throw new BadRequestException(INVALID_EVOLUTION_FORM);        }        List<Category> categories;        categories = evolutionRequestDTO.getCategories().stream()                .map(Category::fromText)                .collect(Collectors.toList());        if(categories.size()>3){            throw new BadRequestException(EXCEED_CATEGORY_COUNT);        }        EvolvedBogu entity = new EvolvedBogu();        entity.setProblem(evolutionRequestDTO.getProblem());        entity.setCategories(categories);        Collections.shuffle(categories);        Category selectedCategory = categories.get(0);        entity.setSelectedCategory(selectedCategory);        Random rand = new Random();        Integer variation = rand.nextInt(getVariation(selectedCategory));        entity.setVariation(variation);        entity.setName(Type.fromCategoryAndVariation(selectedCategory.getIdx(), variation));        entity.setLevel(getLevel(evolutionRequestDTO.getDefaultBoguId(), selectedCategory));        entity.setStatus(1);        entity.setCount(1);        entity.setCountBang(0);        entity.setLastBangAt(null);        entity.setIsLiberated(false);        entity.setLiberated_at(null);        DefaultBogu defaultForm = defaultBoguService.findDefaultBoguByID(evolutionRequestDTO.getDefaultBoguId());        if(defaultForm.getEvolvedForm()!=null){            throw new BadRequestException(DUPLICATE_EVOLUTION);        }        defaultForm.addEvolvedForm(entity);        defaultBoguRepository.save(defaultForm);        evolvedBoguRepository.save(entity);        return entity.getId();    }    @Transactional    public PopBoguResponseDTO popEvolvedBogu(Long id){        EvolvedBogu findOne = evolvedBoguRepository.findById(id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        Integer findCount = findOne.getCount();        findOne.setCountBang(findOne.getCountBang()+1);        findOne.setLastBangAt(LocalDateTime.now());        if(findCount<=0){            throw new BadRequestException(NEGATIVE_EVOLVED_BOGU_COUNT);        }else{            findOne.setCount(findCount-1);        }        PopBoguResponseDTO res = new PopBoguResponseDTO();        res.setLiberationFlag((findOne.getCountBang()%3)==0);        return res;    }    @Transactional    public void LiberateEvolvedBogu(Long id){        EvolvedBogu findOne = evolvedBoguRepository.findById(id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        if(findOne.getIsLiberated()){            throw new BadRequestException(DUPLICATE_LIBERATION);        }else{            findOne.setIsLiberated(true);            findOne.setLiberated_at(LocalDateTime.now());        }    }    private Integer getLevel(Long id, Category selectedCategory){        DefaultBogu defaultBogu = defaultBoguService.findDefaultBoguByID(id);        Member host = defaultBogu.getHost();        Integer countBogus = defaultBoguRepository.findByHostAndEvolvedFormNotNull(host).size();        if(countBogus<=10){            if(countBogus==0) return 1;            Integer n = evolvedBoguRepository.findByHostAndSelectedCategory(host, selectedCategory).size();            Integer x = n/countBogus*100;            if(0<=x && x<=30) return 1;            else if(x<=50) return 2;            else return 3;        }else{            LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);            Integer n = evolvedBoguRepository.findByHostAndSelectedCategoryAndCreatedAtAfter(host, selectedCategory, thirtyDaysAgo).size();            Integer m = evolvedBoguRepository.findByHostAndCreatedAtAfter(host, thirtyDaysAgo).size();            if(m==0) return 1;            Integer x = n/m*100;            if(0<=x && x<=10) return 1;            else if(x<=20) return 2;            else if(x<=30) return 3;            else if(x<=40) return 4;            else if(x<=50) return 5;            else return 6;        }    }    private Integer getVariation(Category category){        if(category==Category.CATEGORY5 || category==Category.CATEGORY8) return 2;        else if(category==Category.CATEGORY7) return 1;        else if(category==Category.CATEGORY9) return 3;        else return 4;    }    private Integer getStatus(Integer level, LocalDateTime createdAt){        LocalDateTime now = LocalDateTime.now();        Duration duration = Duration.between(createdAt, now);        Integer speed;        switch (level) {            case 1: speed = 6; break;            case 2: speed = 5; break;            case 3: speed = 4; break;            case 4: speed = 3; break;            case 5: speed = 2; break;            case 6: speed = 1; break;            default: throw new BadRequestException(INVALID_LEVEL);        }        if(duration.toHours() >= 8 * speed){            return 9;        }else if(duration.toHours() >= 7 * speed){            return 8;        }else if(duration.toHours() >= 6 * speed){            return 7;        }else if(duration.toHours() >= 5 * speed){            return 6;        }else if(duration.toHours() >= 4 * speed){            return 5;        }else if(duration.toHours() >= 3 * speed){            return 4;        }else if(duration.toHours() >= 2 * speed){            return 3;        }else if(duration.toHours() >= 1 * speed){            return 2;        }else{            return 1;        }    }    private Integer getCount(Integer count, Integer level, LocalDateTime LastBangAt){        LocalDateTime now = LocalDateTime.now();        Duration duration = Duration.between(LastBangAt, now);        Integer maxBangs;        Integer bangFrequency;        switch (level) {            case 1: maxBangs = 3; bangFrequency = 6; break;            case 2: maxBangs = 4; bangFrequency = 5; break;            case 3: maxBangs = 5; bangFrequency = 4; break;            case 4: maxBangs = 5; bangFrequency = 3; break;            case 5: maxBangs = 6; bangFrequency = 2; break;            case 6: maxBangs = 7; bangFrequency = 1; break;            default: throw new BadRequestException(INVALID_LEVEL);        }        if(duration.toHours() >=bangFrequency && count<=maxBangs){            return count+1;        }else{            return count;        }    }}