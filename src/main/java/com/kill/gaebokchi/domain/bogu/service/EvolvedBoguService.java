package com.kill.gaebokchi.domain.bogu.service;import com.kill.gaebokchi.domain.archive.*;import com.kill.gaebokchi.domain.bogu.entity.Category;import com.kill.gaebokchi.domain.bogu.entity.DefaultBogu;import com.kill.gaebokchi.domain.bogu.entity.EvolvedBogu;import com.kill.gaebokchi.domain.bogu.entity.Type;import com.kill.gaebokchi.domain.bogu.dto.request.EvolutionRequestDTO;import com.kill.gaebokchi.domain.bogu.dto.response.EvolvedBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.dto.response.PopBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.dto.response.dogam.CollectedBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.dto.response.dogam.DetailDogamBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.dto.response.dogam.DogamBoguResponseDTO;import com.kill.gaebokchi.domain.bogu.repository.DefaultBoguRepository;import com.kill.gaebokchi.domain.bogu.repository.EvolvedBoguRepository;import com.kill.gaebokchi.domain.account.entity.Member;import com.kill.gaebokchi.domain.account.entity.TypeFlag;import com.kill.gaebokchi.global.error.BadRequestException;import jakarta.persistence.EntityManager;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.Duration;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;import static com.kill.gaebokchi.domain.bogu.entity.Category.*;import static com.kill.gaebokchi.global.error.ExceptionCode.*;@Service@Slf4j@Transactional(readOnly = true)@RequiredArgsConstructorpublic class EvolvedBoguService {    private final EvolvedBoguRepository evolvedBoguRepository;    private final DefaultBoguRepository defaultBoguRepository;    private final DefaultBoguService defaultBoguService;    private final ClickBoguTimeRepository clickBoguTimeRepository;    private final DetailDogamTimeRepository detailDogamTimeRepository;    private final DogamTimeRepository dogamTimeRepository;    private final PopTimeRepository popTimeRepository;    //private final EntityManager em;    @Transactional    public EvolvedBoguResponseDTO findEvolvedBoguByID(Member member, Long id) {        EvolvedBogu evolvedBogu = evolvedBoguRepository.findByHostAndId(member, id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        //archive        ClickBoguTime clickBoguTime = ClickBoguTime.builder()                .memberId(member.getId())                .boguId(id)                .clickedAt(LocalDateTime.now())                .build();        clickBoguTimeRepository.save(clickBoguTime);        //archive        return EvolvedBoguResponseDTO.from(evolvedBogu);    }    @Transactional    public void updateEvolvedBogu(Member member){        List<EvolvedBogu> findList = evolvedBoguRepository.findByHostAndIsLiberatedFalse(member);        for(EvolvedBogu findOne : findList){            Integer findCount = findOne.getCount();            Integer findLevel = findOne.getLevel();            LocalDateTime findCreatedAt = findOne.getCreatedAt();            LocalDateTime findBangAt = findOne.getLastBangAt();            Integer newStatus = getStatus(findLevel, findCreatedAt);            findOne.setStatus(newStatus);            if (findBangAt != null) {                Integer newCount = getCount(findCount, findLevel, findBangAt);                findOne.setCount(newCount);            }        }    }    public List<EvolvedBoguResponseDTO> findEvolvedBoguByHost(Member member) {        List<EvolvedBogu> findList = evolvedBoguRepository.findByHostAndNonZeroCount(member);        if(findList==null){            return Collections.emptyList();        }        return findList.stream()                .map(EvolvedBoguResponseDTO::from)                .collect(Collectors.toList());    }    @Transactional    public EvolvedBoguResponseDTO saveEvolvedBogu(Member member, EvolutionRequestDTO evolutionRequestDTO){        if(evolutionRequestDTO.hasNullFields()){            throw new BadRequestException(INVALID_EVOLUTION_FORM);        }        List<Category> categories;        categories = evolutionRequestDTO.getCategories().stream()                .map(Category::fromText)                .collect(Collectors.toList());        if(categories.size()>3){            throw new BadRequestException(EXCEED_CATEGORY_COUNT);        }        Collections.shuffle(categories);        Category selectedCategory = categories.get(0);        Random rand = new Random();        Integer variation = rand.nextInt(getVariation(selectedCategory));        Type type = Type.getTypeFromCategoryAndVariation(selectedCategory.getId(), variation);        EvolvedBogu entity = EvolvedBogu.builder()                .problem(evolutionRequestDTO.getProblem())                .categories(categories)                .selectedCategory(categories.get(0))                .type(type)                .level(getLevel(member, evolutionRequestDTO.getDefaultBoguId(), selectedCategory))                .status(1)                .count(1)                .countBang(0)                .LastBangAt(null)                .isLiberated(false)                .liberatedAt(null)                .build();        DefaultBogu defaultForm = defaultBoguService.findDefaultBoguByID(member, evolutionRequestDTO.getDefaultBoguId());        if(defaultForm.getEvolvedForm()!=null){            throw new BadRequestException(DUPLICATE_EVOLUTION);        }        /*flag설정*/        List<EvolvedBogu> findLists = evolvedBoguRepository.findByHostAndType(member,type);        if(findLists==null || findLists.isEmpty()){            TypeFlag typeFlag = member.getTypeFlag();            List<Boolean> flag = typeFlag.getNewFlag();            flag.set(type.getId(),true);            typeFlag.setNewFlag(flag);        }        evolvedBoguRepository.save(entity);        defaultForm.addEvolvedForm(entity);        return EvolvedBoguResponseDTO.from(entity);    }    @Transactional    public PopBoguResponseDTO popEvolvedBogu(Member member, Long id){        EvolvedBogu findOne = evolvedBoguRepository.findByHostAndId(member, id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        Integer findCount = findOne.getCount();        findOne.setCountBang(findOne.getCountBang()+1);        findOne.setLastBangAt(LocalDateTime.now());        if(findCount<=0){            throw new BadRequestException(NEGATIVE_EVOLVED_BOGU_COUNT);        }else{            findOne.setCount(findCount-1);        }        PopBoguResponseDTO res = new PopBoguResponseDTO();        res.setLiberationFlag((findOne.getCountBang()%3)==0);        //archive        PopTime popTime = PopTime.builder()                .memberId(member.getId())                .boguId(id)                .poppedAt(LocalDateTime.now())                .build();        popTimeRepository.save(popTime);        //archive        return res;    }    @Transactional    public void LiberateEvolvedBogu(Member member, Long id){        EvolvedBogu findOne = evolvedBoguRepository.findByHostAndId(member, id)                .orElseThrow(() -> new BadRequestException(NOT_FOUND_EVOLVED_BOGU_ID));        if(findOne.getIsLiberated()){            throw new BadRequestException(DUPLICATE_LIBERATION);        }else{            findOne.setIsLiberated(true);            findOne.setLiberatedAt(LocalDateTime.now());            TypeFlag typeFlag = member.getTypeFlag();            List<Boolean> liberatedFlag = typeFlag.getLiberatedFlag();            liberatedFlag.set(findOne.getType().getId(),true);            typeFlag.setLiberatedFlag(liberatedFlag);            List<Boolean> newFlag = typeFlag.getNewFlag();            newFlag.set(findOne.getType().getId(), true);            typeFlag.setNewFlag(newFlag);        }    }    private Integer getLevel(Member member, Long id, Category selectedCategory){        DefaultBogu defaultBogu = defaultBoguService.findDefaultBoguByID(member, id);        Member host = defaultBogu.getHost();        Integer countBogus = defaultBoguRepository.findByHostAndEvolvedFormNotNull(host).size();        if(countBogus<=10){            if(countBogus==0) return 1;            Integer n = evolvedBoguRepository.findByHostAndSelectedCategory(host, selectedCategory).size();            Integer x = n/countBogus*100;            if(0<=x && x<=30) return 1;            else if(x<=50) return 2;            else return 3;        }else{            LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);            Integer n = evolvedBoguRepository.findByHostAndSelectedCategoryAndCreatedAtAfter(host, selectedCategory, thirtyDaysAgo).size();            Integer m = evolvedBoguRepository.findByHostAndCreatedAtAfter(host, thirtyDaysAgo).size();            if(m==0) return 1;            Integer x = n/m*100;            if(0<=x && x<=10) return 1;            else if(x<=20) return 2;            else if(x<=30) return 3;            else if(x<=40) return 4;            else if(x<=50) return 5;            else return 6;        }    }    private Integer getVariation(Category category){        if(category== CATEGORY2 || category== CATEGORY4 || category== CATEGORY6 || category== CATEGORY9) return 3;        else if(category== CATEGORY7) return 1;        else if(category== CATEGORY3) return 4;        else return 2;    }    private Integer getStatus(Integer level, LocalDateTime createdAt){        LocalDateTime now = LocalDateTime.now();        Duration duration = Duration.between(createdAt, now);        Integer speed;        switch (level) {            case 1: speed = 6; break;            case 2: speed = 5; break;            case 3: speed = 4; break;            case 4: speed = 3; break;            case 5: speed = 2; break;            case 6: speed = 1; break;            default: throw new BadRequestException(INVALID_LEVEL);        }        if(duration.toHours() >= 8 * speed){            return 9;        }else if(duration.toHours() >= 7 * speed){            return 8;        }else if(duration.toHours() >= 6 * speed){            return 7;        }else if(duration.toHours() >= 5 * speed){            return 6;        }else if(duration.toHours() >= 4 * speed){            return 5;        }else if(duration.toHours() >= 3 * speed){            return 4;        }else if(duration.toHours() >= 2 * speed){            return 3;        }else if(duration.toHours() >= 1 * speed){            return 2;        }else{            return 1;        }    }    private Integer getCount(Integer count, Integer level, LocalDateTime LastBangAt){        LocalDateTime now = LocalDateTime.now();        Duration duration = Duration.between(LastBangAt, now);        Integer maxBangs;        Integer bangFrequency;        switch (level) {            case 1: maxBangs = 3; bangFrequency = 6; break;            case 2: maxBangs = 4; bangFrequency = 5; break;            case 3: maxBangs = 5; bangFrequency = 4; break;            case 4: maxBangs = 5; bangFrequency = 3; break;            case 5: maxBangs = 6; bangFrequency = 2; break;            case 6: maxBangs = 7; bangFrequency = 1; break;            default: throw new BadRequestException(INVALID_LEVEL);        }        if(duration.toHours()/bangFrequency >=1){            Integer newCount = count + (int)duration.toHours()/bangFrequency;            if(newCount<=maxBangs){                return newCount;            }else{                return maxBangs;            }        }else{            return count;        }    }    @Transactional    public DogamBoguResponseDTO getDogamBogus(Member member){        List<EvolvedBogu> evolvedBogus = evolvedBoguRepository.findByHost(member);        List<CollectedBoguResponseDTO> collectedBogus = groupEvolvedBogus(member, evolvedBogus);        DogamBoguResponseDTO res = new DogamBoguResponseDTO();        res.setCountKinds(collectedBogus.size());        res.setCollectedBogus(collectedBogus);        //archive        DogamTime dogamTime = DogamTime.builder()                .memberId(member.getId())                .time(LocalDateTime.now())                .build();        dogamTimeRepository.save(dogamTime);        //archive        return res;    }    private List<CollectedBoguResponseDTO> groupEvolvedBogus(Member member, List<EvolvedBogu> bogus){        Map<Type, List<EvolvedBogu>> groupedBogus = bogus.stream()                .collect(Collectors.groupingBy(EvolvedBogu::getType));        List<CollectedBoguResponseDTO> collectedBogus = new ArrayList<>();        for(Type type : Type.values()){            List<EvolvedBogu> findLists = groupedBogus.get(type);            if(findLists!=null && !findLists.isEmpty()){                CollectedBoguResponseDTO collectedBogu = CollectedBoguResponseDTO.from(type);                /*flag 설정*/                //newFlag                TypeFlag typeFlag = member.getTypeFlag();                List<Boolean> newFlag = typeFlag.getNewFlag();                collectedBogu.setNewFlag(newFlag.get(type.getId()));                //liberatedFlag                List<Boolean> liberatedFlag = typeFlag.getLiberatedFlag();                collectedBogu.setLiberatedFlag(liberatedFlag.get(type.getId()));                collectedBogus.add(collectedBogu);            }        }        return collectedBogus;    }    @Transactional    public List<DetailDogamBoguResponseDTO> findDogamBoguById(Member member, Integer typeId){        Type type = Type.fromId(typeId);        List<DetailDogamBoguResponseDTO> res = evolvedBoguRepository.findByHostAndType(member,type).stream()                .map(DetailDogamBoguResponseDTO::from)                .toList();        //archive        DetailDogamTime detailDogamTime = DetailDogamTime.builder()                .memberId(member.getId())                .typeId(typeId)                .time(LocalDateTime.now())                .build();        detailDogamTimeRepository.save(detailDogamTime);        //archive        return res;    }    @Transactional    public void deleteNewFlag(Member member, Integer typeId){        TypeFlag typeFlag = member.getTypeFlag();        List<Boolean> flag = typeFlag.getNewFlag();        flag.set(typeId,false);        typeFlag.setNewFlag(flag);    }}